\chapter{Fazit}
\label{sec:fazit}
\epigraph{Write the tests you wish you had. If you don’t, you will eventually break sth. while refactoring. Then you’ll get bad feelings abt. refactoring and stop doing it so much. Then your design will deteriorate. You’ll be fired. Your dog will leave you. You will stop paying attention to your nutrition. Your teeth will go bad. So, to keep your teeth healthy retroactively test before refactoring.}{Kent Beck \citep{beck_test_2002}}

Die im Rahmen dieser Diplomarbeit entwickelte Web-Anwendung ist zum gegenwärtigen Zeitpunkt noch nicht fertiggestellt. Aufgrund einer Repriorisierung innerhalb der Firma wird diese vorraussichtlich 2012 weiter entwickelt werden. Gleichwohl kann die Entwicklung als Erfolg gewertet werden, da alle Qualitätskennzahlen einen wesentlichen Unterschied gegenüber den bisherigen Projekten aufzeigen. Im Großen ist dies der testgetriebene\index{TDD}n Entwicklung und der ständigen Beobachtung der Code-Metrik\index{Code-Metrik}en zu verdanken. Dank der testgetriebenen Entwicklung entstand relativ lose gekoppelter Code und ein feinmaschiges Testnetz, dank dem Hinweise aus den Code-Metriken leicht umgesetzt werden konnten.

Allerdings \randbem{Lernkurve von TDD}hat sich gezeigt, dass die Umstellung auf eine testgetriebene\index{TDD} Entwicklung nicht von heute auf morgen stattfinden kann. Das konstante Testen-Vor\hyp{}Implementieren bedarf insbesondere in der Anfangsphase einer hohen Disziplin, da es leicht ist, in das alte Schema zurückzufallen. Auch das Schreiben der Tests sollte gelernt werden. Eine große Anzahl an Tests ist zwar wünschenswerte, aber lange nicht ausreichend für eine Beurteilung der Testvollständigkeit oder ein gar Beweis für eine Korrektheit des untersuchten Programmes.

Die \randbem{Grenzen von TDD}testgetriebene\index{TDD} Entwicklung ist allerdings kein Allheilmittel ("`Silver Bullet"') für alle Probleme der Software-Entwickler. Der Einsatz von TDD erfordert vom Programmierer ein hohes Maß an Eigenverantwortung und ein hohes Wissen über Software-Design, um Refaktorisierung\index{Refaktorisierung}en sinnvoll durchführen zu können. TDD kann auch nicht davor schützen, ein falsches Produkt zu entwickeln, da die Anforderungen falsch verstanden wurden. Außerdem stellt die testgetriebene Entwicklung keinen Ersatz für andere Arten von Tests wie Performanz-, Stress- und Usability-Tests dar. Auch lassen sich einige Probleme schlecht mittels TDD testen und implementieren, darunter Nebenläufigkeit oder Sicherheit. Auch benötigt TDD auf kurze Sicht betrachtet mehr Zeit bei der Entwicklung, dafür kann es auf lange Sicht Zeit beim Debuggen sparen, da die Tests schnell Anhaltspunkte über Ursachen der Fehler geben.
Die Effektivität einer testgetriebene\index{TDD}n Entwicklung ist auch maßgeblich von den vorhanden Werkzeugen innerhalb der Programmiersprache und Framework abhängig. So verfügen die weitverbreiteten Sprachen über ein Vielzahl von Werkzeugen, die den Prozess unterstützen, z.B. Code-Metrik\index{Code-Metrik}en, parallelisierbare Test-Runner oder hochentwickelte Test-Frameworks.

Die \randbem{Positive Effekte}Erfahrung und bisherige Studien haben aber gezeigt, dass durch den konsequenten Einsatz der testgetriebene\index{TDD}n Entwicklung im Schnitt deutlich besserer Code hinsichtlich der Komplexität und des Umfangs produziert wird und auch die Testung selbst stark vereinfacht wird, da Code und Test \index{Test}gemeinsam entstehen und nicht im Nachhinein.

Insgesamt ist TDD\index{TDD} eine Technik, die es nach Ansicht des Autors wert ist, von jedem Programmierer gelernt zu werden. Bisherige Studien und Erfahrungen zeigen fast überwiegend positive Auswirkungen von TDD. Die Technik ist zwar schnell beschrieben ("`Red"' "`Green "' "`Refactor"'), allerdings bedarf es viel Übung, diesen Zyklus beizubehalten und scheinbar schwierig zu testende Probleme anzugehen.

\section{Ausblick}
Wie \randbem{Weiterentwicklung von IT-Jobs\index{IT-Jobs-Projekt}}erwähnt ist die Entwicklung der Anwendung noch nicht abgeschlossen und wird zu gegebener Zeit fortgesetzt. In diesem Zusammenhang werden dann häufiger Akzeptanztest\index{Akzeptanztest}s als treibende Kraft eingesetzt und deren Auswirkungen untersucht werden (vgl. \ref{sec:acceptance}, \ref{sec:attd} und \ref{sec:system}).

Der \randbem{Ausbau der Benchmarks}hier gezeigte Ansatz eines Benchmarks der Code-Qualität innerhalb der Ruby/Rails\hyp{}Community kann so ausgebaut werden, dass weitere Parameter untersucht werden und deutlich mehr Projekte einfließen, um so letztendlich repräsentative Kennzahlen darüber zu erhalten, was eine gute Code-Qualität für Railsanwendungen ausmacht. Dazu wird in Zukunft ein Benchmarking\hyp{}Tool entwickelt, welches die Messungen halbautomatisch vornehmen wird. Leider ist die Situation bei den Metrik-Werkzeugen nicht optimal; viele Werkzeuge funktionieren nur in der älteren Ruby Version 1.8.7. Allerdings nutzen viele der aktuellen Anwendungen bereits Features, die nur die Ruby Version 1.9.x unterstützt. Hier wäre eine teilweise Neuentwicklung einiger Messwerkzeuge sinnvoll.

Interessant \randbem{Erfahrungen mit TDD}wäre, die Effektivität von TDD in Abhängigkeit von der eigenen Erfahrung mit dieser Technik zu untersuchen, um daraus Schlussfolgerungen zu ziehen, wie lange ein Programmierer im Durchschnitt benötigt, um effektiv testgetrieben zu entwickeln. Ebenfalls wären Studien über die psychologische Auswirkungen von TDD für die pludoni GmbH interessant, da erfahrene TDD-Entwickler zwar gefühlsmäßig wissen, dass TDD einen Fluss erzeugt und richtig angewendet Spaß macht, aber dies nicht anhand von empirischen Zahlen belegen können.

Innerhalb der pludoni GmbH werden außerdem zukünftige Ruby\index{Ruby}-Projekte mittels TDD\index{TDD} durchgeführt, um weitere Erfahrungen zu sammeln. Falls diese Erkenntnisse als Fallstudie für die Wissenschaft interessant sein sollten, so werden sie veröffentlicht.

